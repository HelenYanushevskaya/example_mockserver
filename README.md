Моки в тестировании и автоматизации
========================
Что такое мокирование и зачем? 
-----------------------
   В начале ответим на вопрос зачем. Очень часто на своих проектах я сталкивалась с тем что мне нужно либо создать много и разных данных для своего теста либо заставить API работать, и в первом и во втором случае это было делать нелегко а иногда и невозможно. Не долго думая я начала изучать возможности перехвата и изменения запросов и первое что мне попалось на глаза это Charles и Fidler. С помощью этих двух сервисов я мог быстро изменить запросы приходящие с бэка и отобразить нужную мне информацию. 
   
   Так что же такое мокирование? Мокирование это процесс изменния запроса под ваши нужды. Например: у вас есть с фронта на бэк /messages, который отдает список всех сообщений из чата и вам нужно проверить как будет отображается более 1000 сообщений в диалоге. А можно пойти простым путем а насоздавать все 1000 сообщений потратив где-то около часа, а можно пойти более интересным способом и получить пример json объекта этого сообщения и продублировать части с сообщеними несколько раз и при использовании Charles или Fidler замокировать этот запрос.
  
  Со временем мои задачи становились сложее и мне уже нужно мокировать не только отдельные запросы но и целые сервисы и делать это уже не просто для тестирования но и для автоматизации. Так я и пришла к опенсорсному инструменту mockserver.
   Вот что вам понадобится:
    - Flask - фреймворк для создания веб-приложений на языке программирования Python
    - request - HTTP-библиотека
    - Pytest - тестовый фреймворк
    - Seleium - это инструмент для автоматизации действий веб-браузера
    - mockserver - бесплатный фреймворк для проксирования и мокирования HTTP и HTTPS запросов
   
  План статьи:
  1. Создание простого сервера для примера 
  2. Установка всех моск ссервера
  3. Создание мока
  4. Написание теста для обычного запроса
  5. Написание теста для запросов с моками 
  6. Написание теста для браузера с моками

   Для начала создадим маленькое серверное приложение суть которого вернуть нам список сообщений если мы авторизованы, либо вернуть ошибку авторизации если не аворизованы, при этом авторизация это сторинний сервис. Создим python проект и установим все нужные нам библиотеки
   
    pip install Flask
    pip install requests
    pip install pytest
    pip install selenium
   
   Создание сервера
   ------
  В созданный проект, добавив app.py в корень проекта 
  
```  
import os

import requests
from flask import Flask, render_template

app = Flask(__name__)

json_messages = {
    'result': [
        {
            "text": "Hello!",
            "date_created": "2021-09-17T18:34:35"
        }
    ]
}

@app.route('/messages')
def messages():
    return json_messages


@app.route('/messages_auth')
def messages_auth():
    response = requests.get("http://192.168.1.233:1082/authorization")
    if response.status_code == 200:
        return json_messages
    else:
        return {"error": "Authorization failed"}

@app.route('/')
def base():
    message = 'Check browser'
    return render_template("index.html", message=message)

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=1081)
```
И чтобы было немного интереснее добавим template/index.html. 
```
<div>
    <b>Welcome!</b><br>
    <p id="message">{{ message }} </p>
</div>
```

Запустим наш сервер с помощью команды  ```python app.py```. Проверить что все хорошо можно с помощью браузер, просто вызвать наш сервер с помощью запроса


Теперь установим mockserver c помощью команды ```brew install mockserver``` и запустим ```mockserver -logLevel INFO -serverPort 1080```. У mockserver есть удобный дашборд на котором можно посмотрееть все историю запросов которые через него прошли http://localhost:1080/mockserver/dashboard



Осталось только добавить настройки для проксирования наших запросов, это можно сделать 2умя способами: через переменную окружения, например в начало app.py добавить ```os.environ['HTTP_PROXY'] = 'http://0.0.0.0:1080'``` либо добавить в нужном нам запросе проксирование через параметр proxi.

Запустим наш сервер еще раз но уже с настройкой прокси и выполним запрос в браузере.

    

